<!DOCTYPE html>
<html>
  <head>
    <title>Street Lights in ACT</title>
    <style type="text/css">
      .suburbLabels {
        color: white;
      }

      body {
        background-color: #050c26;
      }

      .streetlights {
        color: white;
      }

      .switch {
        cursor: pointer;
      }

      h1 {
        color: white;
      }
    </style>

  </head>
  <body>
    <h1>Street Lights in Northern Canberra Suburbs</h1>
    <div id="drawing"></div>

    <!-- All the scripts needed to get the drawingualisation working -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.6.5/svg.min.js"></script>
  	<script src="https://d3js.org/d3-array.v1.min.js"></script>
  	<script src="https://d3js.org/d3-geo.v1.min.js"></script>
  	<script type="text/javascript" src="data/suburbs.geojson.json"></script>
    <script type="text/javascript" src="data/lights_geometry.geojson.json"></script>
  	<script type="text/javascript" src="data/commute.json"></script>

    <script type="text/javascript">
      var width = 1300;
      var height = 1020;
      var drawing = SVG("drawing").size(width, height);

      var colours = ['lightpink', 'gold', 'sandybrown', 'orchid', 'cyan', 'lightgreen'];
      var lampTypes = ['Compact\nFluorescent', 'Sodium\nLamps', 'Light Emitting\nDiode', 'Metal\nHalide', 'Mercury\nLamps', 'Others /\nNot specified'];
      var lightsOn = [true, true, true, true, true, true];

      var projection = d3.geoMercator()
                          .scale(1)
                          .translate([400, 600]);

      //filter the geojson to include only those suburbs in the bike data list
      geojson.features = geojson.features.filter(g => lightsGeojson.features.some(l => l.properties.suburb == g.properties.ACT_LOCA_2));

      projection.fitExtent([[20,20],[1000,1000]], geojson);

      var mapPath = d3.geoPath(projection);

      geojson.features.forEach(f => {
        dataValue = commuteData[f.properties.ACT_LOCA_2];
        var sg = drawing.group();
        var outline = sg.path(mapPath(f)).id(f.properties.ACT_LOCA_2);
        outline.fill('#050c26');
        //outline.stroke({color: 'lightgray', width: 2});
        //outline.stroke({color: 'black'});


        // // store the label text on the group
        // sg.labelString = f.properties.ACT_LOCA_2 + " - " + Math.floor(dataValue*100)+'%';
        // // and the geo path data
        // sg.geoPath = f;
        //
        sg.on('mouseenter', function(){
          // outline.stroke({color: 'lightgray', width: 2});
          //label = drawing.text(this.labelString).move(mapPath.centroid(this.geoPath)[0],mapPath.centroid(this.geoPath)[1]);
        })

        sg.on('mouseleave', function(){
          // outline.stroke('none');
          //label.remove();
        })

      });

      var fluorescentArray = [];
      var sodiumArray = [];
      var ledArray = [];
      var halideArray = [];
      var mercuryArray = [];
      var miscArray = [];

      lightsGeojson.features.forEach(f => {
        var sg = drawing.group();

        mapPath.pointRadius(10); // make this (10 * f.properties.outreach)
        var outreach = sg.path(mapPath(f));
        outreach.opacity(0.1);

        mapPath.pointRadius(1.5); // sets the radius of the street lights to 1
        var points = sg.path(mapPath(f)); // draw the points across the map

        // Handler for turning the lights on and off
        outreach.on('toggleOnOff', function(e) {
          if (!lightsOn[e.detail.index]) {
            outreach.animate(100, '-', 0).opacity(0.1);
          } else {
            outreach.animate(100, '-', 0).opacity(0);
          }
        })

        // Compact fluorescent lights
        if (f.properties.lampType === "COMPACT FLUORESCENT") {
          points.fill(colours[0]);
          outreach.fill(colours[0]);
          fluorescentArray.push(outreach);
        }
        // Sodium lights
        else if (f.properties.lampType === "HIGH PRESSURE SODIUM"
                || f.properties.lampType === "SODIUM VAPOUR HIGH PRESSURE"
                || f.properties.lampType === "SODIUM VAPOUR HIGH PRESSURE TW"
                || f.properties.lampType === "SODIUM VAPOUR LOW PRESSURE") {
          points.fill(colours[1]);
          outreach.fill(colours[1]);
          sodiumArray.push(outreach);
        }
        // LED lights
        else if (f.properties.lampType === "LIGHT EMITTING DIODE") {
          points.fill(colours[2]);
          outreach.fill(colours[2]);
          ledArray.push(outreach);
        }
        // Metal halide lights
        else if (f.properties.lampType === "METAL HALIDE") {
          points.fill(colours[3]);
          outreach.fill(colours[3]);
          halideArray.push(outreach);
        }
        // Mercury lights
        else if (f.properties.lampType === "MERCURY HIGH PRESURE FLUORESCE"
                || f.properties.lampType === "MERCURY HIGH PRESURE PHOSPHOR"
                || f.properties.lampType === "MERCURY LOW PRESURE FLUORESCEN"
                || f.properties.lampType === "MERCURY VAPOUR") {
          points.fill(colours[4]);
          outreach.fill(colours[4]);
          mercuryArray.push(outreach);
        }
        // Unidentified lamp types or small categories
        else {
          points.fill(colours[5])
          outreach.fill(colours[5]);
          miscArray.push(outreach);
        }
        points.addClass('streetlights');

        let box;

        sg.on('mouseenter', function(event){
          box = drawing.group();
          box.rect(420, 100)
              .fill('white')
              .attr({'fill-opacity': 0.6})
              .stroke('black')
              .move(event.pageX + 5, event.pageY - 20);
          box.text(f.properties.suburb + " STREET LIGHT")
              .attr({'text-anchor': "middle"})
              .move(event.pageX + 215, event.pageY - 20 + 15)
              .addClass("infoTitle")

          let outreachText = (f.properties.outreach === "NONE" || f.properties.outreach === "") ? "N/A outreach detected of lamp type " + f.properties.lamp : f.properties.outreach + "m outreach";
          box.text(outreachText)
              .attr({'text-anchor': "middle"})
              .move(event.pageX + 215, event.pageY - 20 + 40)
              .addClass("infoDesc");
          box.text("Column properties: " + f.properties.columnHeight + " of " + f.properties.columnMaterial)
              .attr({'text-anchor': "middle"})
              .move(event.pageX + 215, event.pageY - 20 + 70)
              .addClass("infoDesc");
          // console.log(d3.mouse(this));
          // label = drawing.text("This is a text").move(mapPath.centroid(this.geoPath)[0],mapPath.centroid(this.geoPath)[1]);
        })

        sg.on('mouseleave', function(){
          box.remove();
          // label.remove();
        })
      })

      var boxmarginX = 120;
      var boxmarginY = 150;
      for (let i = 0; i < 6; i++) {
        drawing.rect(280, 100)
                .fill('lightcyan')
                .stroke({color: 'lightseagreen', width: 5})
                .move(width - 250 - boxmarginX, boxmarginY + i * 100);
        let legendColours = drawing.rect(100, 40)
                                    .fill(colours[i])
                                    .move(width - 250 - boxmarginX + 20, boxmarginY + i * 100 + 30)
        let toggleSwitch = drawing.rect(40, 40)
                            .fill('white')
                            .move(width - 250 - boxmarginX + 80, boxmarginY + i * 100 + 30)

        let button = drawing.rect(100, 40)
                           .fill('white')
                           .attr({'fill-opacity': 0})
                           .stroke({colour: 'black', width: 3})
                           .move(width - 250 - boxmarginX + 20, boxmarginY + i * 100 + 30)
                           .addClass('switch');

        button.click(function() {
          toggleSwitch.fire('toggleOnOff');
          legendColours.fire('toggleColours');

          if (i == 0) {
            fluorescentArray.forEach(light => {
              light.fire('toggleOnOff', {index: i});
            })
          } else if (i == 1) {
            sodiumArray.forEach(light => {
              light.fire('toggleOnOff', {index: i});
            })
          } else if (i == 2) {
            ledArray.forEach(light => {
              light.fire('toggleOnOff', {index: i});
            })
          } else if (i == 3) {
            halideArray.forEach(light => {
              light.fire('toggleOnOff', {index: i});
            })
          } else if (i == 4) {
            mercuryArray.forEach(light => {
              light.fire('toggleOnOff', {index: i});
            })
          } else if (i == 5) {
            miscArray.forEach(light => {
              light.fire('toggleOnOff', {index: i});
            })
          }

          lightsOn[i] = !lightsOn[i];
        })

        toggleSwitch.on('toggleOnOff', function() {
            if (!lightsOn[i]) {
              toggleSwitch.animate(200, '>', 0).move(width - 250 - boxmarginX + 80, boxmarginY + i * 100 + 30);
            } else {
              toggleSwitch.animate(200, '>', 0).move(width - 250 - boxmarginX + 20, boxmarginY + i * 100 + 30);
            }
        })

        legendColours.on('toggleColours', function() {
          if (!lightsOn[i]) {
            legendColours.animate(100, '>', 0).fill(colours[i]);
          } else {
            legendColours.animate(100, '>', 0).fill('darkgray');
          }
        })

        drawing.text(lampTypes[i])
                .move(width - 250 - boxmarginX + 140, boxmarginY + i * 100 + 32)
      }

      /*geojson.features.forEach(f => {
        dataValue = commuteData[f.properties.ACT_LOCA_2];
        var sg = drawing.group();
        var overlay = sg.path(mapPath(f)).id(f.properties.ACT_LOCA_2);
        overlay.fill('#0e2549');
        overlay.stroke({width: 3, color: 'white'});
        overlay.opacity(0);

        // store the label text and the path on the group
        sg.labelString = f.properties.ACT_LOCA_2;
        sg.geoPath = f;


        sg.on('mouseenter', function(){
          overlay.opacity(0.5);
          label = drawing.text(this.labelString)
                    .move(mapPath.centroid(this.geoPath)[0] - this.labelString.length * 5,mapPath.centroid(this.geoPath)[1])
                    .fill('white');
        })

        sg.on('mouseleave', function(){
          overlay.opacity(0);
          label.remove();
        })

      });*/

    </script>
  </body>
</html>
