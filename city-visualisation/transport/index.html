<!DOCTYPE html>
<html>
  <head>
    <title>ACT Transport</title>
    <style type="text/css">
      .clickable {
        cursor: move;
      }

    </style>

  </head>
  <body>
    <h1>ACT Average Passenger Boardings by Service Type</h1>
    <div id="drawing"></div>

    <!-- All the scripts needed to get the drawingualisation working -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/2.6.5/svg.min.js"></script>
  	<script type="text/javascript" src="data/transport.json"></script>

    <script type="text/javascript">
      var draw = SVG("drawing").size(1200, 1000);

      const numCategories = 4;

      // Prepare the data by putting them into arrays
      var monthArray = new Array(transportData.length / 4);
      var transportArray = new Array(transportData.length / 4);
      var passengersArray = new Array(transportData.length / 4);
      for (let i = 0; i < transportArray.length; i++) {
        transportArray[i] = new Array(numCategories);
        monthArray[i] = transportData[i * numCategories].month;
        var totalPassengers = 0;
        for (let j = 0; j < numCategories; j++) {
          transportArray[i][j] = transportData[i * numCategories + j].avBoardings;
          totalPassengers += transportArray[i][j];
        }
        passengersArray[i] = totalPassengers;
      }

      var yScale = 4;
      var xMargin = 650;
      var barWidth = 30;
      var barSpacing = 40;
      var yBottom = 500;

      // clickable timeline
      var lineYMargin = 150;
      var lineXMargin = 100;
      var lineLength = 880;
      var pointSpacing = 80;
      draw.line(lineXMargin, yBottom + lineYMargin, lineLength + lineXMargin, yBottom + lineYMargin)
          .stroke({color: 'blue', width: 10, linecap: 'round'});

      // Pie chart
      // Based on tutorial https://danielpataki.com/svg-pie-chart-javascript/
      const chartSize = 400;
      const margin = 50;
      const selectOpacity = 0.7;

      var sectors = new Array(transportArray.length);
      var colors = [
          "lightseagreen", "lightcoral", "green", "darkorange"
      ];

      for (let i = 0; i < transportArray.length; i++) {

        var l = chartSize / 2;
        var a = 0; // Angle
        var aRad = 0; // Angle in Rad
        var z = 0; // Size z
        var x = 0; // Side x
        var y = 0; // Side y
        var X = 0; // SVG X coordinate
        var Y = 0; // SVG Y coordinate
        var R = 0; // Rotation

        sectors[i] = [];
        transportArray[i].map(function(item, key) {
          let percentage = item / passengersArray[i];
          a = 360 * percentage;
          aCalc = (a > 180) ? 360 - a : a;
          aRad = aCalc * Math.PI / 180;
          z = Math.sqrt(2 * l * l - (2 * l * l * Math.cos(aRad)));
          if (aCalc <= 90) {
            x = l * Math.sin(aRad);
          } else {
            x = l * Math.sin((180 - aCalc) * Math.PI / 180 );
          }

          y = Math.sqrt(z * z - x * x);
          Y = y;

          if (a <= 180) {
            X = l + x;
            arcSweep = 0;
          } else {
            X = l - x;
            arcSweep = 1;
          }

          sectors[i].push({
            percentage: percentage,
            color: colors[key],
            arcSweep: arcSweep,
            L: l,
            X: X,
            Y: Y,
            R: R
          });
          R = R + a;
        })
      }

      //sectors = calculateSectors(data);
      // sectors[0].map(function(sector) {
      //     var path = draw.path('M' + (sector.L + margin) + ',' + (sector.L + margin) + ' L' + (sector.L + margin) + ', ' + margin + ' A' + sector.L + ',' + sector.L + ' 1 0,1 ' + (sector.X + margin) + ', ' + (sector.Y + margin) + ' z');
      //     path.fill(sector.color);
      //     path.rotate(sector.R, sector.L + margin, sector.L + margin);
      //     //newSector.setAttributeNS(null, 'transform', 'rotate(' + sector.R + ', '+ sector.L+', '+ sector.L+')');
      //
      //     path.mouseover(function(){
      //       path.opacity(selectOpacity);
      //       //label = drawing.text("This is a text").move(mapPath.centroid(this.geoPath)[0],mapPath.centroid(this.geoPath)[1]);
      //     })
      //
      //     path.mouseout(function(){
      //       path.opacity(1);
      //       //label.remove();
      //     })
      // });


      //var point = draw.circle(10).center(sectors[0][1].L, 10);
      //point.rotate(sectors[0][1].R, sectors[0][1].L, sectors[0][1].L);


      var bars = new Array(transportArray.length);
      var textSpacing = 40;
      for (let i = 0; i < sectors.length; i++) {
        let cumulativeHeight = 0;
        bars[i] = new Array(numCategories);
        // total = transportArray[i][0] + transportArray[i][1] + transportArray[i][2] + transportArray[i][3];
        // console.log(total);
        // draw.rect(barWidth, total * yScale).move(xMargin + i * barSpacing, yBottom - total * yScale).fill('black');
        for (var j = 0; j < sectors[i].length; j++) {
          var value = transportArray[i][j];
          bars[i][j] = draw.rect(barWidth, value * yScale)
              .move(xMargin + i * barSpacing, yBottom - value * yScale - cumulativeHeight * yScale)
              .fill(colors[j])
              .stroke({color: 'black', width: 0.5});
          cumulativeHeight += value;
        }

        var textOffsetX = 20;
        var textOffsetY = 10;
        draw.text(monthArray[i])
            .move(xMargin + i * textSpacing + textOffsetX, yBottom + textOffsetY)
            .rotate(45, xMargin + i * textSpacing + textOffsetX, yBottom + textOffsetY)
            .attr({'text-anchor': "start"});
      }


      // X and y axes
      const marginOffset = 10;
      draw.line(xMargin - marginOffset, yBottom, xMargin - marginOffset, yBottom - 500)
          .stroke({color: 'black', width: 2});
      draw.line(xMargin - marginOffset, yBottom, xMargin + barSpacing * sectors.length + 20, yBottom)
          .stroke({color: 'black', width: 2});

      // Ticks
      var ticks = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120];
      var ticksOffset = marginOffset + 5;
      var labelsOffsetX = 5;
      var labelsOffsetY = 5;
      var ylabels = new Array(ticks.length);
      for (let i = 0; i < ylabels.length; i++) {
        draw.line(0, 0, 10, 0)
            .stroke({color: 'black', width: 2})
            .move(xMargin - ticksOffset, yBottom - ticks[i] * yScale);

        draw.text(ticks[i] + "")
            .move(xMargin - ticksOffset - labelsOffsetX, yBottom - ticks[i] * yScale - labelsOffsetY)
            .attr({'text-anchor': "end"});
      }

      // The timeline part
      for (let i = 0; i < monthArray.length; i++) {
        let offset = 25;
        draw.text(monthArray[i])
            .move(lineXMargin + i * pointSpacing, lineYMargin + yBottom + offset)
            //.rotate(45, xMargin + i * pointSpacing + textOffsetX, yBottom + textOffsetY)
            .attr({'text-anchor': "middle"});

        let scrollbar = draw.circle(25)
            .center(lineXMargin + i * pointSpacing, lineYMargin + yBottom)
            .fill('white')
            .stroke({color:'blue', width: 5})
            .addClass('clickable');

        scrollbar.mouseover(function() {
          scrollbar.fill('lightblue');
        });

        scrollbar.mouseout(function() {
          scrollbar.fill('white');
        })

        scrollbar.click(function() {
          draw.circle(chartSize).center(chartSize / 2 + margin, chartSize / 2 + margin).fill('white');
          sectors[i].map(function(sector, key) {
              let path = draw.path('M' + (sector.L + margin) + ',' + (sector.L + margin) + ' L' + (sector.L + margin) + ', ' + margin + ' A' + sector.L + ',' + sector.L + ' 1 0,1 ' + (sector.X + margin) + ', ' + (sector.Y + margin) + ' z');
              path.fill(sector.color);
              path.rotate(sector.R, sector.L + margin, sector.L + margin);
              //newSector.setAttributeNS(null, 'transform', 'rotate(' + sector.R + ', '+ sector.L+', '+ sector.L+')');

              path.mouseover(function(){
                path.opacity(selectOpacity);
                for (let j = 0; j < transportArray.length; j++) {
                  for (let k = 0; k < numCategories; k++) {
                    if (k != key) {
                      bars[j][k].opacity(0);
                    } else {
                      bars[j][k].move(xMargin + j * barSpacing, yBottom - transportArray[j][k] * yScale);
                    }
                  }
                }
              })

              path.mouseout(function(){
                path.opacity(1);
                for (let j = 0; j < transportArray.length; j++) {
                  let cumulativeHeight = 0;
                  for (let k = 0; k < numCategories; k++) {
                    if (k != key) {
                      bars[j][k].opacity(1);
                      cumulativeHeight += transportArray[j][k];
                    } else {
                      bars[j][k].move(xMargin + j * barSpacing, yBottom - transportArray[j][k] * yScale - cumulativeHeight * yScale);
                    }
                  }
                }
              })
          });

          var midCircle = draw.circle(chartSize * 0.28 * 2);
          midCircle.fill('white');
          midCircle.center(chartSize * 0.5 + margin, chartSize * 0.5 + margin);

          // for (let j = 0; j < numCategories; j++) {
          //   bars[i][j].opacity(selectOpacity);
          // }


          // Change this to just be moved, instead of creating on everytime.
          let rectOffsetX = 30;
          let rectOffsetY = 70;
          draw.rect(lineLength + 100, 50)
              .move(lineXMargin - rectOffsetX, lineYMargin + yBottom - rectOffsetY)
              .fill('white');
          draw.circle(20)
              .fill('blue')
              .center(lineXMargin + i * pointSpacing, lineYMargin + yBottom - 50);
          let leftVertex = (lineXMargin + i * pointSpacing - 10) + ',' + (lineYMargin + yBottom - 48) + ' ';
          let rightVertex = (lineXMargin + i * pointSpacing + 10) + ',' + (lineYMargin + yBottom - 48) + ' ';
          let bottomVertex = (lineXMargin + i * pointSpacing) + ',' + (lineYMargin + yBottom - 28) + ' ';
          draw.polygon(leftVertex + rightVertex + bottomVertex).fill('blue');

        })
      }

      sectors[0].map(function(sector, key) {
          let path = draw.path('M' + (sector.L + margin) + ',' + (sector.L + margin) + ' L' + (sector.L + margin) + ', ' + margin + ' A' + sector.L + ',' + sector.L + ' 1 0,1 ' + (sector.X + margin) + ', ' + (sector.Y + margin) + ' z');
          path.fill(sector.color);
          path.rotate(sector.R, sector.L + margin, sector.L + margin);
          //newSector.setAttributeNS(null, 'transform', 'rotate(' + sector.R + ', '+ sector.L+', '+ sector.L+')');

          path.mouseover(function(){
            path.opacity(selectOpacity);
            for (let j = 0; j < transportArray.length; j++) {
              for (let k = 0; k < numCategories; k++) {
                if (k != key) {
                  bars[j][k].opacity(0);
                } else {
                  bars[j][k].move(xMargin + j * barSpacing, yBottom - transportArray[j][k] * yScale);
                }
              }
            }
          })

          path.mouseout(function(){
            path.opacity(1);
            for (let j = 0; j < transportArray.length; j++) {
              let cumulativeHeight = 0;
              for (let k = 0; k < numCategories; k++) {
                if (k != key) {
                  bars[j][k].opacity(1);
                  cumulativeHeight += transportArray[j][k];
                } else {
                  bars[j][k].move(xMargin + j * barSpacing, yBottom - transportArray[j][k] * yScale - cumulativeHeight * yScale);
                }
              }
            }
          })
      });


      var midCircle = draw.circle(chartSize * 0.28 * 2);
      midCircle.fill('white');
      midCircle.center(chartSize * 0.5 + margin, chartSize * 0.5 + margin);


      draw.circle(20)
          .fill('blue')
          .center(lineXMargin, lineYMargin + yBottom - 50);
      let leftVertex = (lineXMargin - 10) + ',' + (lineYMargin + yBottom - 48) + ' ';
      let rightVertex = (lineXMargin + 10) + ',' + (lineYMargin + yBottom - 48) + ' ';
      let bottomVertex = (lineXMargin) + ',' + (lineYMargin + yBottom - 28) + ' ';
      draw.polygon(leftVertex + rightVertex + bottomVertex).fill('blue');

      var legendBoxWidth = 420;
      var legendBoxHeight = 75;
      var legendMarginX = 60;
      var legendMarginY = 480;
      draw.rect(legendBoxWidth, legendBoxHeight)
          .move(legendMarginX, legendMarginY)
          .fill('none')
          .stroke({color: 'black'});

      draw.line(0, 0, 30, 0)
          .stroke({color: colors[0], width: 7,linecap: 'round'})
          .move(legendMarginX + 20, legendMarginY + 20)
      draw.text(transportData[0].serviceType).move(legendMarginX + 65, legendMarginY + 15);
      draw.line(0, 0, 30, 0)
          .stroke({color: colors[1], width: 7,linecap: 'round'})
          .move(legendMarginX + 250, legendMarginY + 20)
      draw.text(transportData[1].serviceType).move(legendMarginX + 295, legendMarginY + 15);
      draw.line(0, 0, 30, 0)
          .stroke({color: colors[2], width: 7,linecap: 'round'})
          .move(legendMarginX + 20, legendMarginY + 55)
      draw.text(transportData[2].serviceType).move(legendMarginX + 65, legendMarginY + 50);
      draw.line(0, 0, 30, 0)
          .stroke({color: colors[3], width: 7,linecap: 'round'})
          .move(legendMarginX + 250, legendMarginY + 55)
      draw.text(transportData[3].serviceType).move(legendMarginX + 295, legendMarginY + 50);

    </script>
  </body>
</html>
